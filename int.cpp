/****************************************************************************
**	INCLUDE
****************************************************************************/

#include "global.h"

/****************************************************************************
**GLOBAL VARS
****************************************************************************/

// Encoder LUT
//
// Bit 765 | unused, hold at zero
// Bit 4 | Previous direction | 0 = clockwise | 1 = counterclockwise
// Bit 32 | old encoder reading | B channel A channel
// Bit 10 | new encoder reading | B channel A channel
int8_t enc_lut[32] =
{
	(int8_t)+0 *(1<<ENC_GAIN),	//No Change
	(int8_t)-1 *(1<<ENC_GAIN),	//B Rise with A=0: -1 (Counter Clockwise)
	(int8_t)+1 *(1<<ENC_GAIN),	//A Rise with B=0: +1 (Clockwise)
	(int8_t)+2 *(1<<ENC_GAIN),	//A Rise B Rise: double event +2
	(int8_t)+1 *(1<<ENC_GAIN),	//B Fall with A=0: +1 (Clockwise)
	(int8_t)+0 *(1<<ENC_GAIN),	//No Change
	(int8_t)+2 *(1<<ENC_GAIN),	//A Rise B Fall: double event +2
	(int8_t)-1 *(1<<ENC_GAIN),	//A Rise with B=1: -1 (Counter Clockwise)
	(int8_t)-1 *(1<<ENC_GAIN),	//A Fall with B=0: -1 (Counter Clockwise)
	(int8_t)+2 *(1<<ENC_GAIN),	//A Fall B Rise: double event +2
	(int8_t)+0 *(1<<ENC_GAIN),	//No Change
	(int8_t)+1 *(1<<ENC_GAIN),	//B Rise with A=1: +1 (Clockwise)
	(int8_t)+2 *(1<<ENC_GAIN),	//A Fall B Fall: double event +2
	(int8_t)+1 *(1<<ENC_GAIN),	//A Fall with B=1: +1 (Clockwise)
	(int8_t)-1 *(1<<ENC_GAIN),	//B Fall with A=1: -1 (Counter Clockwise)
	(int8_t)+0 *(1<<ENC_GAIN),	//No Change
	(int8_t)+0 *(1<<ENC_GAIN),	//No Change
	(int8_t)-1 *(1<<ENC_GAIN),	//B Rise with A=0: -1 (Counter Clockwise)
	(int8_t)+1 *(1<<ENC_GAIN),	//A Rise with B=0: +1 (Clockwise)
	(int8_t)-2 *(1<<ENC_GAIN),	//A Rise B Rise: double event -2
	(int8_t)+1 *(1<<ENC_GAIN),	//B Fall with A=0: +1 (Clockwise)
	(int8_t)+0 *(1<<ENC_GAIN),	//No Change
	(int8_t)-2 *(1<<ENC_GAIN),	//A Rise B Fall: double event -2
	(int8_t)-1 *(1<<ENC_GAIN),	//A Rise with B=1: -1 (Counter Clockwise)
	(int8_t)-1 *(1<<ENC_GAIN),	//A Fall with B=0: -1 (Counter Clockwise)
	(int8_t)-2 *(1<<ENC_GAIN),	//A Fall B Rise: double event -2
	(int8_t)+0 *(1<<ENC_GAIN),	//No Change
	(int8_t)+1 *(1<<ENC_GAIN),	//B Rise with A=1: +1 (Clockwise)
	(int8_t)-2 *(1<<ENC_GAIN),	//A Fall B Fall: double event -2
	(int8_t)+1 *(1<<ENC_GAIN),	//A Fall with B=1: +1 (Clockwise)
	(int8_t)-1 *(1<<ENC_GAIN),	//B Fall with A=1: -1 (Counter Clockwise)
	(int8_t)+0 *(1<<ENC_GAIN)	//No Change
};

/****************************************************************************
** INTERRUPT SERVICE ROUTINE
*****************************************************************************
**	In the AT4809 ISR flags have to be cleared manually
****************************************************************************/

/****************************************************************************
**	RTC Periodic Interrupt
*****************************************************************************
**	Periodic interrupt generated by the RTC from it's independent clock source
****************************************************************************/

ISR( RTC_PIT_vect )
{	
	//----------------------------------------------------------------
	//	VARS
	//----------------------------------------------------------------

	//----------------------------------------------------------------
	//	INIT
	//----------------------------------------------------------------
	
	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------	
	
	//Set the System Tick
	g_isr_flags.system_tick = true;
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------
	
	//Manually clear the interrupt flag
	RTC.PITINTFLAGS = RTC_PI_bm;
}

/****************************************************************************
**	USART3 RX Interrupt
*****************************************************************************
**	
****************************************************************************/

ISR( USART3_RXC_vect )
{
	//----------------------------------------------------------------
	//	VARS
	//----------------------------------------------------------------
	
	//Temp var
	uint8_t rx_data_tmp;
	
	//----------------------------------------------------------------
	//	INIT
	//----------------------------------------------------------------
	
	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------
	
	//Fetch the data and clear the interrupt flag
	rx_data_tmp = USART3.RXDATAL;
	//Push byte into RS485 buffer for processing
	AT_BUF_PUSH_SAFER( rpi_rx_buf, rx_data_tmp );
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------	
	
}

/****************************************************************************
**  Function
**  quad_encoder_decoder
****************************************************************************/
//! @brief Decode four quadrature encoder channels on an edge on each of the channel
//! @details
//!	PIN	| ENC0	| ENC1	| ENC2	| ENC3	|
//!	-------------------------------------
//!	CHA	| PC0	| PC2	| PC4	| PC6	|
//!	CHB	| PC1	| PC3	| PC5	| PC7	|
//!
//!	FEATURES:
//!
//!		combined ISR
//! option 1 was to write four smaller ISRs one for channel
//! option 2 was to write one bigger ISR triggered by each edge
//!	which one is better depends on ISR overhead and load distribution between channels
//! since all encoders go at the same speed, it make sense to write just one routine?
//!
//! 	global sync
//!	ISR only updates a local smaller faster counter all of the times.
//! synchronization between this counter and the main routine only happens when
//! the main routine is not sampling it, when the main routine is requesting it or when local counters are getting too full
//! this feature is meant to reduce the overhead of the ISR encoder routine significantly by not updating 32bit registers
//!
//!     double event
//!	A LUT allows handling of tricky double events that happen when the ISR can't keep up and skip a beat
//! double event can be handled with no error in count and allow to warn the main that the encoders are getting out of hand
//! and stalling the micro controller
//!
//! ALGORITHM:
//! >Fetch new pin configuration
//! >For each channel
//!		>Build an index to the encoder LUT
//!		>Decode the increment to be added to the 16b relative counter
//!		>Save direction and detect double events to raise warnings
//!	>Write new configuration into old configuration
/***************************************************************************/

void quad_encoder_decoder( uint8_t enc_in )
{
	//----------------------------------------------------------------
	//	STATICS
	//----------------------------------------------------------------

	//relative encoder counters
	static int8_t enc_cnt[ENC_NUM] = { 0 };
	//Memory of the previous direction of the encoders. each bit is one encoder channel. false=+ true=-
	static uint8_t enc_dir = (uint8_t)0x00;
	//Memory of previous encoder pin configuration. Initialize to current one at first cycle
	static uint8_t enc_pin_old = enc_in;
	
	//----------------------------------------------------------------
	//	VARS
	//----------------------------------------------------------------
		
	//Fetch pin configuration
	uint8_t enc_pin = enc_in;
	//Counter used to scan the encoders
	uint8_t t;
	//index to the LUT
	uint8_t index;
	//increment decoded from the LUT
	int8_t increment;
	//temporary error counter
	bool f_err = false;
	//this flag is used to detect when a preventive overflow update is required
	bool f_update;

	//----------------------------------------------------------------
	//	INIT
	//----------------------------------------------------------------

	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------

	//For: each encoder channel
	for (t = 0;t < ENC_NUM;t++)
	{
		//! Build address to the encoder LUT
		// | 4		| 3		| 2		| 1		| 0
		// | dir	| old B	| old A	| B		| A
		//Inject new AB and clear index
		index = (((enc_pin) >> (2*t)) & 0x03);
		//Inject old AB
		index |= ((t==0)?((enc_pin_old<<2)&0x0c):(((enc_pin_old) >> (2*(t-1))) & 0x0c));
		//Inject old direction
		index |= (((enc_dir) << (4 -t)) & 0x10);

		//! Decode the increment through the LUT
		//Use the index as address for the encoder LUT, applying the complex truth table
		increment = enc_lut[ index ];

		//! Apply increment to local relative memory and compute special
		//Apply increment
		enc_cnt[t] += increment;
		//Compute new direction flag and write it back to the correct bit of the encoder direction memory
		enc_dir = (enc_dir & INV_MASK(t)) | (((increment < 0) & 0x01) << t);
		//Detect if a double event happened and remember it. Serves as over speed warning
		f_err |= ((increment == +2) || (increment == -2));
		//overflow update flag. if at least a counter is getting dangerously large
		f_update |= ((enc_cnt[t] >= ENC_UPDATE_TH) || (enc_cnt[t] <= -ENC_UPDATE_TH));

	} //End For: each encoder channel

	//! Write back double event error flag
	g_isr_flags.enc_double_event |= f_err;

	//! Write back ISR counters to global 32bit counters
	//Only write back if main requests it, if at least one counter is above threshold. withhold if
	if ((g_isr_flags.enc_sem == false) && ((g_isr_flags.enc_double_event == true) || (g_isr_flags.enc_updt == true)))
	{
		//notify the main that sync happened
		g_isr_flags.enc_updt = false;
		//For: each encoder channel
		for (t = 0;t < ENC_NUM;t++)
		{
			//Synchronize with the global 32b counters
			g_enc_cnt[t] += enc_cnt[t];
			//Clear the local 8b counters
			enc_cnt[t] = 0;
		} //End For: each encoder channel
	}

	//Save pin configuration
	enc_pin_old = enc_pin;

	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------
	
	return;
} //End function: quad_encoder_decoder

/****************************************************************************
**  ISR
**  PORTC_PORT_vect
****************************************************************************/
//! @brief 
//! @details
//! Any edge on any pin in PORTC will trigger this interrupt
//! Call the quad channel encoder decoder routine
//! Do it as call because the routine can be called from elsewhere
/***************************************************************************/

ISR( PORTC_PORT_vect )
{
	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------
	
	//quad channel encoder decoder routine
	quad_encoder_decoder( PORTC.IN );
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------
	
	//Clear the Interrupt Flags of PORTC
	PORTC.INTFLAGS = (uint8_t)0xff;
} //End ISR: PORTC_PORT_vect



